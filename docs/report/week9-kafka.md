# Week 9 - 카프카란 무엇인가?

**작성일**: 2025-12-19
**프로젝트**: HHPlus E-Commerce Backend

---

## 1. 개요

### 1.1 카프카란 무엇인가?
카프카는 '고성능 분산 이벤트 스트리밍 플랫폼'이다. 아주 많은 양의 데이터를 실시간으로 수집하고, 저장하며, 필요한 곳으로 안전하게 전달해 주는 중간 전달자 역할을 수행한다.

**탄생 배경**
- **링크드인(LinkedIn)**의 내부 데이터 파이프라인 구조가 Point-to-Point 방식으로 파편화되어 관리가 불가능한 수준에 이르자, 이를 해결하기 위해 개발되었다.
- 기존 메시지 브로커와 달리, 실시간 대용량 로그 데이터를 지연 없이 처리하는 데 초점을 맞춘다.

### 1.2 전통적인 메시징 시스템(RabbitMQ) vs 카프카 비교
| 특징 | RabbitMQ (Message Broker) | Kafka (Event Streaming) |
| :--- | :--- | :--- |
| **목적** | 메시지 전달 보장 및 복잡한 라우팅 | 대용량 실시간 로그 처리 및 스트리밍 |
| **데이터 보관** | 소비되면 즉시 삭제 (휘발성) | 설정된 기간/용량만큼 디스크 저장 (영속성) |
| **처리량** | 초당 수만 건 수준 | 초당 수백만 건 이상의 대량 처리 |

---

## 2. 카프카 핵심 구조와 용어

### 2.1 Producer & Consumer
* **Producer:** 데이터를 생성하여 카프카 토픽으로 전송한다.
* **Consumer:** 토픽에서 데이터를 읽어서 처리한다. 'Consumer Group'을 통해 부하를 분산한다.

### 2.2 Topic & Partition
* **Topic:** 데이터가 들어가는 커다란 분류 항목이다.
* **Partition:** 토픽을 물리적으로 나눈 단위로, 메시지가 실제로 저장되는 공간이다.

### 2.3 Broker & Cluster
* **Broker:** 카프카가 설치된 서버 한 대를 의미한다.
* **Cluster:** 여러 브로커를 묶어 고가용성과 확장성을 확보한 전체 시스템이다.

---

## 3. 카프카의 주요 특징

### 3.1 복제(Replication)와 고가용성
* **ISR (In-Sync Replicas):** 리더(Leader) 파티션과 완벽하게 동기화된 복제본들의 그룹이다. 리더가 중단되면 ISR 중 하나가 즉시 리더가 되어 서비스를 지속한다.

### 3.2 분산 및 확장성
* 파티션을 여러 브로커에 분산 배치함으로써 서버 한 대의 성능 한계를 뛰어넘는다. 트래픽이 늘어나면 브로커를 추가하여 성능을 선형적으로 확장한다.

### 3.3 영속성 (Persistence)
* 메시지를 메모리가 아닌 디스크에 저장한다. 덕분에 장애가 발생해도 데이터가 유실되지 않으며, 컨슈머가 과거의 데이터를 다시 읽는 것도 가능하다.

---

## 4. 내부 동작 원리

카프카가 데이터를 처리하는 핵심은 메시지의 '생성-저장-소비' 과정에서 발생하는 병목을 최소화하고 신뢰성을 확보하는 데 있다.

### 4.1 메시지 전송 과정

1. **직렬화 및 파티셔닝:** 프로듀서가 메시지를 보내기 전, 데이터를 바이트 형태로 직렬화하고 어떤 파티션으로 보낼지 결정한다.
2. **배치 적재:** 전송 효율을 높이기 위해 메시지를 즉시 보내지 않고 내부 버퍼(Record Accumulator)에 파티션별로 모은다.
3. **전송 및 응답:** 설정된 배치 크기나 시간에 도달하면 브로커로 전송하며, 설정된 `acks` 옵션에 따라 브로커로부터 성공 응답을 받는다.

**핵심 원리**
프로듀서는 **Batching** 원리를 이용하여 네트워크 오버헤드를 줄인다. 수많은 작은 메시지를 개별적으로 보내는 대신 하나의 큰 묶음으로 전송하여 처리량을 극대화한다. 또한 메시지 키를 활용한 해시 파티셔닝 원리를 통해 특정 키를 가진 메시지들이 항상 동일한 파티션에 순서대로 쌓이도록 보장한다.

### 4.2 메시지 저장 과정

1. **요청 수신 및 캐싱:** 브로커는 프로듀서로부터 받은 데이터를 먼저 OS의 페이지 캐시(Page Cache)에 기록한다.
2. **순차 쓰기:** 캐시에 기록된 데이터는 백그라운드에서 디스크의 로그 파일 끝에 순차적으로 기록된다(Append-only).
3. **인덱스 업데이트:** 데이터 저장과 동시에 해당 메시지의 위치를 찾을 수 있도록 인덱스 파일에 오프셋과 물리적 주소를 기록한다.

**핵심 원리**
카프카 저장의 핵심은 **순차 I/O(Sequential I/O)** 원리에 있다. 하드디스크는 무작위 위치를 찾는(Random Access) 속도는 느리지만, 끝부분에 이어서 쓰는 속도는 매우 빠르다는 점을 이용한다. 또한 OS 레벨의 **페이지 캐시**를 적극 활용하여, 디스크에 직접 접근하는 횟수를 줄임으로써 메모리 기반 시스템에 준하는 속도를 구현한다.

### 4.3 메시지 소비 과정

1. **페치 요청(Fetch Request):** 컨슈머는 자신이 읽어야 할 오프셋 정보를 담아 브로커에 데이터를 요청한다.
2. **데이터 전송(Zero-copy):** 브로커는 디스크나 페이지 캐시에 있는 데이터를 컨슈머에게 전달한다.
3. **오프셋 커밋:** 데이터를 처리한 컨슈머는 어디까지 읽었는지를 `__consumer_offsets` 토픽에 기록하여 다음 읽기 위치를 확정한다.

**핵심 원리**
컨슈머는 **Pull 방식**의 메커니즘을 채택한다. 브로커가 데이터를 강제로 밀어넣지 않기 때문에, 컨슈머는 자신의 처리 능력에 맞춰 데이터를 가져오는 흐름 제어(Flow Control)가 가능하다. 전송 시에는 **Zero-copy** 원리를 적용하여, 데이터를 커널 영역에서 유저 영역으로 복사하는 불필요한 CPU 연산을 생략하고 커널 메모리에서 바로 네트워크 카드로 데이터를 쏴줌으로써 전송 속도를 극대화한다.

---

## 5. 궁금했었던 내용

**Q. RabbitMQ와 Kafka 중 언제 무엇을 써야 하는가?**
**A.** **RabbitMQ**는 복잡한 라우팅이 필요하거나 메시지가 처리되는 즉시 삭제되어야 하는 가벼운 통신에 유리하다. 반면 **Kafka**는 대량의 실시간 로그 수집, 데이터 영속성 보장, 그리고 과거 데이터를 다시 읽어야 하는 분석 환경에서 압도적인 우위를 점한다.

**Q. 카프카 클러스터 구성의 보편 방식은 무엇인가?**
**A.** 보통 최소 **3대의 브로커**로 구성하는 것이 표준이다. `Replication Factor`를 3으로 두어 브로커 한 대가 장애로 빠져도 서비스 가용성을 유지한다. 데이터 안전을 위해 `min.insync.replicas`를 2로 설정하여 리더 외에 최소 한 대의 팔로워가 동기화되었음을 보장받는 것이 보편적이다.

**Q. 파티션 개수는 많을수록 좋은가?**
**A.** 파티션이 많으면 병렬 처리량이 증가하여 속도가 빨라지지만, 그만큼 관리해야 할 파일 핸들러와 메타데이터가 늘어난다. 리밸런싱 시간과 장애 복구 시간이 길어질 수 있으므로, 예상되는 처리량에 맞춰 적절히 산정하고 점진적으로 늘리는 것이 권장된다.